# آزمایش اول - آز نرم

## گزارش

برای انجام این آزمایش، یک repo در گیتهاب به صورت عمومی ساخته شد. سپس فایل README.md را در آن ساختیم.

برای انجام مطلوبات آزمایش، یک پروژه‌ی ساده تعریف کردیم: «ماشین حساب با پایتون».

فرآیند ساخت فایل این پروژه در شاخه‌ی dev انجام شد، و شاخه‌ی main هم شاخه‌ی پیش‌فرض آن است.

همچنین برای ایجاد conflict، شاخه‌های feat-sub و feat-divide-multiply ساخته شدند و در هرکدام، یک feature جدید برای ماشین حساب توسعه داده شد (تفریق، تقسیم و ضرب). همزمان شاخه‌ی dev را هم تغییر دادیم تا هنگام ادغام این شاخه‌ها با dev، به conflict بخوریم. بعد از برطرف کردن هر conflict و ادغام شاخه با dev؛ برای اضافه شدن feature جدید به شاخه‌ی پیش‌فرض پروژه، dev را با main ادغام کردیم.

تمامی ادغام‌ها به وسیله‌ی pull request انجام شدند، چه ادغام با dev و چه ادغام با main.
البته شاخه‌ی main را محافظت کرده‌ایم، به صورتی که ادغام با آن تنها از این طریق امکان‌پذیر است.

فایل .gitignore هم به این پروژه اضافه شد، اما چیزی وجود نداشت که بخواهیم آن را نادیده بگیریم :)

پس دو مسیر فرضی برای نادیده گرفتن در پروژه در نظر گرفتیم و آنها را به فایل .gitignore اضافه کردیم.

## پاسخ به پرسش‌ها

#### پاسخ سوال 1

این پوشه یک پوشه‌ی مخفی است که زمان ساخت ریپو آن هم ایجاد می‌شود.
این پوشه شامل تمام metadataها و objectهایی است که برای تغییر در فایل های درون ریپو مورد نیاز می‌باشند.
با ایجاد ریپو به کمک دستور git init ایجاد خواهد شد.

#### پاسخ سوال 2

اتمی بودن به طور کلی به معنای غیر قابل تقسیم بودن است. در مورد کامیت اتمی منظور این است که تغییرات یا به طور کامل انجام می‌شود یا خیر. commit ناقص نداریم.

دستور atomic pull-request نیز به همین منوال است که درخواست به طور کامل انجام شود و اگر بخشی از آن با شکست مواجه شد کل آن انجام نشود.

#### پاسخ سوال 3

دستور merge در واقع دو branch را می‌تواند ادغام کند. pull از روی ریپو فایل‌ها را به ریپوی داخلی می‌آورد ( یا در واقع دانلود می‌کند) و البته همزمان ادغام هم می‌کند. اما fetch همان کار را بدون ادغام انجام می‌دهد.

#### پاسخ سوال 4

دستور reset، ریپوی لوکال را به یکی از کامیت‌های پیشین برمی‌گرداند. اگر این تغییرات فقط در پروژه‌ی لوکال خود ما نبود (پوش شده بود)؛ باید از دستور revert برای این کار استفاده کرد، پس revert ریپوی remote را به یکی از کامیت‌های پیشین برمی‌گرداند.

دستور rebase، پایه‌ی یک شاخه (branch) را تغییر می‌دهد، یعنی برای مثال پس از تغییر پایه‌ی شاخه‌ی "الف" به "ب"، می‌توان گفت که شاخه‌ی "الف" از آخرین تغییرات شاخه‌ی "ب" منشعب شده است و همه‌ی کامیت‌های آن، بعد از کامیت‌های شاخه‌ی "ب" قرار می‌گیرند.

#### پاسخ سوال 5

فایل‌ها در گیت می‌توانند ۳ حالت داشته باشند:

1. modified
2. staged
3. commited

حالت اول یعنی فایل مورد نظر با فایلی که در دیتابیس گیت ثبت شده، متفاوت است (تغییر کرده است).
حالت دوم یعنی تغییرات نسخه‌ی حاضر این فایل، آماده‌ی کامیت شدن هستند.
حالت سوم یعنی فایل کامیت شده است.

در واقع هنگام کامیت کردن، فایل‌هایی که stage شده‌اند در کامیت مورد نظر ثبت می‌شوند و همان نسخه‌ای از آنها ثبت می‌شود که stage شده است، اگر بعد از stage شدن باز فایل را تغییر بدهیم، این تغییرات stage نمی‌شوند و در حالت modified باقی می‌مانند.

دستور stash فایل‌های modify شده را در یک stack ذخیره می‌کند؛ و می‌توان از آن برای تغییر برنچ یا انجام یک کامیت دیگر و سپس بازگرداندن فایل‌هایی که بر روی آنها کار می‌کردیم، استفاده کرد.

#### پاسخ سوال 6

در واقع snapshot یک کپی از روی وضعیت پروژه در یک زمان مشخص را به ما نشان می‌دهد که تعیین می‌کند که تاریخچه تغییرات، ساختار دایرکتوری و commitها و داده‌ها چه هستند.
